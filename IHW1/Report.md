# ИДЗ №1
*Шиндяпкин Илья Дмитриевич БПИ-219*
## Задание
### Вариант №28
Сформировать массив В из элементов массива А, которые образуют неубывающую последовательность. Неубывающей последовательностью считать элементы идущие подряд, которые равны между собой или каждый последующий больше предыдущего. 
***
То есть мы будем искать все последовательности длины 1 < n <= length, образующие неубывающую последовательность и вносить их из массива А в массив В. 
## Часть на 4-5.
В папке под названием "4-5" находится код на С, и код на ассемблере, которые используют локальные переменные и функции с параметрами, для обработки задаваемого массива, а так же папка с тестами, где есть входные данные и соответствующие им выходные. То есть программа сразу выполнена, чтобы удовлетворять критериям на 4 и 5 баллов. Есть исполняемые файлы для обеих версий программы: a.out для версии, написанной на С, а b.out для версии, написанной на ассемблере. Обе программы протестированы на входных данных и выдают корректные результаты. Обе версии кода прокомментированы, в коде на ассемблере подробно объяснена каждая строка по всем приведенным критериям. Код на С был скомпилирован с флагами и подчищен вручную, дабы убрать макросы и ненужные директивы. 
***
Код на С был скомпилирован со следующими флагами:
-masm=intel (для использования синтаксиса Intel)
-fno-asynchronous-unwind-tables (отключает генерацию отладочной информации)
-fno-jump-tables (отключает использование jump-таблиц в switch-case конструкциях)
-fno-stack-protector (отключение стекового индикатора)
-fno-exceptions (позволяет корректно работать с исключениями)
***
Дублирование тестовых данных:

Тест 1:

	Входные данные:
	7
	0 1 2 2 3 1 2
	Выходные данные:
    0 1 2 2 3 1 2
Тест 2:

	Входные данные:
	5
	6 5 -10 100 0
	Выходные данные:
    -10 100
Тест 3:

	Входные данные:
	10
	5 9 0 1 -23 0 0 2 3 4
	Выходные данные:
    5 9 0 1 -23 0 0 2 3 4
Тест 4:

	Входные данные:
    3
	1 1 1
	Выходные данные:
    1 1 1
Тест 	5:

    Входные данные:
    7
	5 4 3 2 1 0 -1
	Выходные данные:
    no output
Тест 6:

	Входные данные:
    10
	9 1 2 3 8 6 4 8 1 10
	Выходные данные:
    1 2 3 8 4 8 1 10
Тест7:

	Входные данные:
    8
	9 3 2 1 2 2 3 4
	Выходные данные:
    1 2 2 3 4
***

## Часть на 6.
Были модифицированы функции обработки массива. Теперь для каждой локальной переменной и параметров были выделены постоянные регистры соответствующих размеров, вместо выделения места на стеке, что ускоряет работу. 

В функции fillOutputArray:
 - rbp[-24] -> r11
 - rbp[-32] -> r12
 - rbp[-36] -> r13d
 - r[-4] -> r14d
 - r[-8] -> r15d

В функции PrintArray:
 - rbp[-24] -> r13
 - rbp[-28] -> r14d
 - rbp[-4] -> r15d
***
Так же из всех функций были убраны излишние конструкции по типу двойного переноса значения по регистрам. Пример:
	    
	    mov     eax, r15d
		mov     esi, eax 

Переписанный вариант:

	    mov		esi, r15d
***
Оптимизирован процесс обращения по индексу массива, где это было возможно. Пример:

        lea     rdx, 0[0+rax*4]
        mov     rax, r13
        add     rax, rdx
        mov     edx, DWORD PTR [rax]
Переписанный вариант:

        lea     rdx, 0[0+rax*4]
        mov     edx, DWORD PTR [r13+rdx]
***
Функция была проверена на тех же тестах и показывала корректные результаты.
